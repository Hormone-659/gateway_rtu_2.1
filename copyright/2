网关RTU智能监测与报警系统软件（下篇说明）

四、核心业务流程（下篇，报警计算与RTU写入）

本章节承接上篇，对从“故障等级汇总”到“报警输出与RTU寄存器写入”的后半部分流程进行说明，对应代码主要位于：
- `src/core/alarm/alarm_engine.py`
- `src/gateway/alarm/alarm_play/alarm_logic.py`
- `src/services/alarm_service.py`
- `src/services/rtu_comm.py`
- `src/gateway/alarm/alarm_level/` 下各级报警配置文件

4.1 报警引擎总体设计

报警子系统的主要职责，是把传感器服务给出的各测点故障等级（0~3级），按照既定业务规则转换为：
1. 总体报警等级（overall alarm level，0~3级），用于表示当前工况严重程度；
2. 一组需要写入RTU/PLC的寄存器值（如3501、3502、3505~3520、40101/43501等），用于驱动现场联锁和状态指示。

为实现这一目标，系统在`core/alarm/alarm_engine.py`中定义了`FaultLevels`和`AlarmEngine`：
- `FaultLevels`：作为报警引擎的输入数据结构，承载各监测点的故障等级（例如曲柄左、曲柄右、轴承、光电、电气状态等）；
- `AlarmEngine`：作为对网关原有报警逻辑的无UI封装，内部调用`gateway.alarm.alarm_play.alarm_logic`模块，得到RTU寄存器写入映射表。

通过这种方式，报警算法本身（包含具体寄存器映射规则）集中在`alarm_logic.py`中，而`AlarmEngine`起到适配层作用，方便后台服务调用，也便于将来替换报警算法实现。

4.2 报警逻辑核心模块

网关原有的报警逻辑位于`src/gateway/alarm/alarm_play/alarm_logic.py`，该模块在本项目中被复用并增强，主要包含以下内容：
1. 报警等级到寄存器的映射关系（如3502表示综合报警等级，3504表示故障类型编码，3505~3512表示各部位是否存在故障标志等）；
2. 三级报警触发后的停机控制逻辑（向寄存器101写入停机命令值82）；
3. 停机状态反馈与锁存逻辑（通过3501和43501寄存器反映设备运行/停机状态）；
4. 针对光电/振动/电气组合情况的故障类型判断与降级规则。

该模块以`SensorState`数据结构为输入，封装了以下关键函数：
- `build_rtu_registers(state, current_rtu_101=None) -> Dict[int, int]`
  - 根据各监测点的故障等级和当前控制寄存器状态，计算出本周期需要写入RTU的寄存器字典；
  - 内部实现了综合报警等级计算、故障类型判定、三级报警触发逻辑及101/3501/43501之间的联动规则。

4.3 综合报警等级与故障类型判定

在`build_rtu_registers`中，首先根据传入的`SensorState`计算每个子模块的报警等级：
1. 振动类监测点等级：取曲柄左右、中部轴承、尾部轴承、马头等部位的最大故障等级；
2. 皮带/光电等级：根据光电监测点的故障等级确定是否存在跑偏/断带等；
3. 电气等级：根据三相状态（elec_phase_a_ok / b / c）统计缺相数量，将其映射为0/1/2级电气故障；
4. 载荷/位置（loadpos）等级：根据载荷或位置信号判断是否异常。

随后，报警逻辑会取上述各部分的最大值，得到总体报警等级`overall_alarm_level`（对应寄存器3502）：
- 若任一监测点为3级，同时电气和载荷正常，则有可能将综合等级降为2级，用于区分“传感器瞬时3级但系统整体并非严重故障”的情况；
- 对于仅有轻微异常的场景，综合等级保持在0或1级。

同时，报警逻辑还会依据当前故障类型组合，计算一个“故障类型编码”写入寄存器3504，例如：
- 同时存在皮带3级报警和电气故障时，标记为特定类型编码；
- 仅振动3级且电气正常时，对应另一种故障类型编码；
- 通过3504配合3505~3512各部位标志位，外部系统可以快速区分故障来源。

4.4 详细状态寄存器（3505~3520）

为便于上位机或RTU侧的人机界面精准显示各部位状态，系统在3505~3520之间定义了一组详细状态寄存器：
- 3505~3512：按位标识各部位是否存在至少1级故障，例如：
  - 3505：曲柄左是否≥1级；
  - 3506：曲柄右是否≥1级；
  - 3507：尾轴承是否≥1级；
  - 3508：中轴承是否≥1级；
  - 3509：马头是否≥1级；
  - 3510：皮带是否≥1级；
  - 3511：电气是否存在缺相等异常；
  - 3512：载荷/位置信号是否异常。
- 3513~3518：分别记录各振动/光电测点的详细故障级别（0~3级），便于精确诊断；
- 3519：记录电气故障等级（0~2级）；
- 3520：记录载荷/位置是否异常（0/1）。

通过这一组寄存器，外部系统可以获得比单一综合报警等级更丰富的诊断信息，形成“总体等级 + 细分部位状态 + 故障类型编码”的多维度报警视图。

4.5 三级报警与101控制寄存器

在本系统中，控制寄存器“101”承担着对现场设备启停的直接控制作用：
- 101 = 81：表示设备运行（或允许运行）；
- 101 = 82：表示设备停机（或下达停机命令）。

`alarm_logic.py`中的核心策略如下：
1. 当综合报警等级（3502）达到3级时，报警逻辑会立即准备向101写入值82，触发停机；
2. 若当前状态尚未处于停机（即回读的101不为82），则在本周期的寄存器写入映射中加入`101=82`；
3. 当不再处于3级报警时，报警逻辑不会自动写回81，以避免出现“自动复位导致误启动”的情况，具体复位由人工或外部系统控制。

此外，报警逻辑会跟踪101最近一次变更的时间戳，用于后续与3501和43501的延时锁存逻辑关联。

4.6 3501运行/停机状态锁存逻辑

寄存器“3501”用于对外反馈设备运行/停机状态，它的值只根据101的变化延时锁存生成，而不直接由报警等级驱动：
- 当101从81变更为82，并保持60秒后，3501锁存为1，表示“停机状态已确认”；
- 当101从82变更为81，并保持60秒后，3501锁存为0，表示“恢复运行状态已确认”。

这部分逻辑在`alarm_logic.py`中通过全局变量 `_g_101_current`、`_g_101_changed_at` 和 `_g_3501_latched` 实现：
1. `build_rtu_registers` 会根据当前从RTU回读的101值更新 `_g_101_current` 和 `_g_101_changed_at`；
2. `_update_3501_latched()` 函数根据当前101值与变更时间，判断是否超过60秒延时：
   - 若满足条件且101=82，则将 `_g_3501_latched` 置为1；
   - 若满足条件且101=81，则将 `_g_3501_latched` 置为0；
3. 在本周期寄存器映射构建时，若 `_g_3501_latched` 有效，则将其写入地址3501。

通过该机制，3501成为一个“去抖动”的状态反馈信号，确保短暂的101波动不会立即影响对外状态显示，从而提高系统稳定性与安全性。

4.7 43501远程/本地状态指示与写入屏蔽

寄存器“43501”在本系统中用于指示某种长期状态（例如“远程控制锁定”、“急停闭锁”或“禁止写入”等），其值与101的状态及时间延时密切相关：
- 当101保持为82达到60秒后，报警逻辑会将43501锁存为1，用于表示一种“长期停机/闭锁”状态；
- 当101保持为81达到60秒后，报警逻辑会将43501锁存为0，用于表示“解除闭锁，允许正常控制”。

同时，`build_rtu_registers` 在处理寄存器时遵循以下规则：
1. 若当前锁存的43501值为1，则优先写入`43501=1`，并可根据需求选择限制其它写操作；
2. 若锁存值为0，但满足101=81且保持60秒的条件，则在本周期将`43501=0`写入RTU，用于明确解除闭锁状态；
3. 具体是否在43501=1时屏蔽所有写操作，可以在逻辑中扩展相应判断，确保紧急停机场景下不会被误复位。

这种双向延时与锁存机制，使得43501既能反映控制逻辑的结果，又能对后续寄存器写入形成保护，适合工业现场对“误操作防护”的实际需求。

4.8 报警服务与RTU通讯服务

报警服务由`src/services/alarm_service.py`实现，其职责是：
1. 周期性读取`sensor_service`输出的JSON状态文件，解析各监测点的故障等级和电气状态；
2. 将这些故障等级封装为`FaultLevels`对象，调用`AlarmEngine.evaluate`获取：
   - 综合报警等级；
   - 需要写入的RTU寄存器映射表；
3. 通过`RtuWriter.write_registers`将寄存器值发送到现场RTU/PLC；
4. 记录报警处理过程中的日志信息，便于远程诊断与问题追踪。

`RtuWriter`类定义在`src/services/rtu_comm.py`中，是对Modbus TCP写寄存器的统一封装：
- 对外提供`write_registers(registers: Dict[int, int], alarm_level: int)`接口；
- 内部对每个工程地址（例如3501、3502、101等）自动减1转换为Modbus PDU地址，并使用功能码0x06逐个写入；
- 提供`read_holding_registers`方法以读取当前101等寄存器的真实状态，供报警逻辑使用；
- 内建简单的日志缓存功能，保留最近几条通讯记录，便于在部署脚本或诊断工具中快速查看。

4.9 部署脚本与运维工具

项目在`deploy/`目录下提供了一整套运维脚本，支持从下载依赖、安装服务、启停服务到日志监控等全流程操作：
1. 安装与更新脚本：
   - `install.sh`：完成Python依赖安装、代码同步、systemd服务配置更新以及服务重启；
   - `download_deps.ps1`等脚本用于离线环境下在Windows上预先下载依赖包。
2. 服务管理脚本：
   - `sensor.service`和`alarm.service`为systemd单元文件，定义了服务运行的工作目录、Python虚拟环境路径、重启策略等；
3. 日志与诊断脚本：
   - `watch_logs.sh`：实时汇总查看传感器服务和报警服务的journal日志；
   - `diagnose_serial.py`、`diagnose_photo.py`：帮助确认现场串口及光电传感器通讯情况；
   - `monitor_rtu.py`：可用于观察RTU侧寄存器变化，验证报警写入是否符合预期。

此外，顶层`CHEAT_SHEET.md`文件汇总了部署、日志查看和常用诊断命令，运维人员可以直接复制粘贴执行，提高现场调试效率。

五、创新点与技术特点总结

1. 分层架构与模块解耦
   - 将采集、阈值算法、报警逻辑、RTU通讯、UI展示等模块分层设计，便于后期扩展和迁移到不同硬件平台；
   - 通过`core/`目录提供与具体网关无关的通用逻辑，使项目具备良好的复用性。

2. 多源传感与综合报警
   - 同时支持振动、光电、电气多种数据源，采用统一的故障等级表示方式；
   - 综合报警等级考虑了多种传感器组合关系，并引入了“3级但电气/载荷正常时自动降级为2级”的业务规则，贴合现场安全策略。

3. 可配置的阈值与时序逻辑
   - 通过`SimpleThresholdConfig`实现不同类型传感器阈值的灵活配置；
   - 利用窗口统计和最小超标点数，兼顾报警敏感度和抗干扰能力；
   - 在三级报警触发停机后，引入101→3501/43501的延时锁存机制，避免因为瞬时波动导致的频繁启停和误判。

4. 统一的RTU寄存器读写封装
   - 自行实现Modbus TCP 0x06单寄存器写入与0x03保持寄存器读取，避免对第三方库的强依赖；
   - 以“工程地址”作为上层接口，内部自动转换为PDU地址，简化业务代码逻辑；
   - 提供最近日志缓存接口，方便在Web界面或诊断工具中直接展示通讯状态。

5. 易部署、易诊断的工程化设计
   - 通过systemd和shell脚本实现“一键部署”和自动重启；
   - 在传感器服务与报警服务中加入详细日志输出，配合`watch_logs.sh`可快速锁定问题所在；
   - 采用JSON状态文件作为模块间数据总线，既便于调试（可直接查看文件内容），又方便其它语言或进程接入。

通过以上设计，本项目构建了一套适用于煤矿/工业现场的“网关+传感+RTU”一体化智能监测与报警软件基础平台，为后续叠加云端监控、大数据分析、远程运维等功能提供了坚实的软件基础。

