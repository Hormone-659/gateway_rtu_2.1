网关RTU智能监测与报警系统软件（上篇说明）

一、软件总体概述

本软件为“网关RTU智能监测与报警系统”，运行在工业现场网关设备上，通过串口/以太网与振动传感器、光电传感器和RTU/PLC进行通信，实现设备状态数据采集、阈值分析、报警判定以及报警结果写入RTU寄存器等功能。软件采用分层架构设计，将传感器采集、阈值算法、报警逻辑、通讯写入等模块进行解耦，便于后期维护和功能扩展。

从整体流程上看，系统主要完成以下闭环：
1. 通过Modbus RTU总线定时采集各类传感器数据（例如振动速度、皮带跑偏/断带的光电脉冲、电气三相电流等）。
2. 将采集到的原始数据按通道送入阈值判定引擎，计算每个监测点的故障等级（0~3级）。
3. 将各监测点故障等级统一汇总为总的报警等级，并根据配置规则生成需要写入RTU/PLC的保持寄存器映射表（如3501、3502、40101等工程地址）。
4. 通过Modbus TCP方式将报警寄存器值写入现场RTU/PLC，实现联锁停机、声光报警、上位机显示等外部动作。
5. 同时在本地生成状态文件和日志，供其它服务或UI程序查询和追溯。

二、系统部署与运行环境

1. 运行平台
   本软件部署在Linux嵌入式工业网关上，使用Python 3.8运行环境。系统通过systemd维护两个常驻后台服务：
   - `sensor.service`：负责传感器采集与阈值分析；
   - `alarm.service`：负责报警等级计算与RTU寄存器写入。

2. 目录结构简要说明
   项目主要目录及其作用如下：
   - `deploy/`：部署相关脚本和systemd服务配置文件，包括安装、日志查看、诊断脚本等；
   - `src/`：核心业务代码目录；
     - `core/`：与具体网关无关的通用核心逻辑模块；
       - `core/modbus/`：Modbus RTU底层通讯封装；
       - `core/sensor/`：阈值引擎、振动数据转换模型等；
       - `core/alarm/`：报警引擎封装，对报警逻辑进行统一适配；
     - `gateway/`：与本项目网关配置相关的逻辑和资源；
       - `gateway/sensor/`：原有的阈值分析与UI逻辑；
       - `gateway/alarm/`：原有报警播放、UI和报警等级配置文件；
     - `services/`：无UI后台服务代码，如`sensor_service.py`和`alarm_service.py`；
   - `sensor_fault_levels.json`：示例或初始的报警阈值配置示意文件；
   - `CHEAT_SHEET.md`：网关日常维护常用命令速查；
   - `requirements.txt`：Python依赖包清单。

三、核心业务流程（上篇，传感器采集与阈值判定）

本章节重点介绍从“传感器数据采集”到“故障等级生成”的前半部分流程，对应代码主要位于：
- `src/services/sensor_service.py`
- `src/core/modbus/rtu_client.py`
- `src/core/sensor/threshold_engine.py`
- `src/core/sensor/vibration_model.py`

3.1 传感器类型与监测对象

系统当前主要监测以下几类对象：
1. 振动类监测点（通过振动速度传感器获得）：
   - 曲柄左（crank_left）
   - 曲柄右（crank_right）
   - 中部轴承（mid_bearing）
   - 尾部轴承（tail_bearing）
   - 马头（horsehead）等
2. 光电类监测点（通过光电传感器获得）：
   - 皮带光电（belt）
   - 对中/断带或其它线型光电（line）
3. 电气类监测点：
   - 三相电流或电压的运行状态（elec_a, elec_b, elec_c），用于判断缺相或电流异常。

每个监测点最终会被赋予一个故障等级`level`，取值范围0~3：
- 0级：正常；
- 1级：轻微异常/预警；
- 2级：中度异常；
- 3级：重度异常（可能触发停机）。

3.2 Modbus RTU采集流程

底层通讯使用`core.modbus.rtu_client.ModbusRtuClient`进行封装，`SensorService`通过它从不同从站单元（unit_id）中读取保持寄存器或输入寄存器，实现多通道数据的批量采集。

典型采集流程如下：
1. 在`sensor_service.py`中，初始化`ModbusRtuClient`并配置串口端口（如`/dev/ttyS2`用于振动传感器，`/dev/ttyS3`用于光电传感器）。
2. 周期性调用 `_read_speed_xyz(unit_id, start_address)` 函数，从指定单元和起始地址读取三个轴向振动原始寄存器值；
3. 调用`raw_to_speed`函数将原始寄存器值转换为以mm/s计的振动速度；
4. 对单轴/三轴数据调用阈值引擎进行等级判断；
5. 同时采集光电传感器寄存器值，用相同的阈值引擎接口进行等级判定。

3.3 振动数据转换与建模

`core/sensor/vibration_model.py`模块负责将传感器返回的原始数值转换为具有物理意义的振动速度值。主要逻辑包括：
1. 原始Modbus寄存器值通常为无符号整型或定点数，需要根据设备标定系数进行缩放；
2. 采用预设的比例因子或公式，将原始数据映射为物理量（单位mm/s）；
3. 为后续阈值判定提供统一的浮点型速度值接口。

这种分层设计使得未来更换传感器型号或标定参数时，只需修改转换模型而不影响阈值算法和报警逻辑。

3.4 阈值引擎与故障等级计算

阈值部分由`core/sensor/threshold_engine.py`封装，对外提供`SimpleThresholdConfig`及`SpeedThresholdEngine`两个核心类：
1. `SimpleThresholdConfig`用于描述单个监测点的三级阈值：
   - `level1`：一级告警阈值；
   - `level2`：二级告警阈值；
   - `level3`：三级告警阈值。
2. `SpeedThresholdEngine`则基于已有的`gateway.sensor.threshold_analyzer`实现，内部使用`MultiChannelThresholdAnalyzer`对多轴数据进行统计和平滑处理：
   - 支持设定滑动窗口大小（window_size），控制报警产生与解除的响应速度；
   - 支持最小超标点数（min_spike_count），避免偶然尖峰引起误报；
   - 通过`evaluate_xyz`或`evaluate_single`接口，将当前时刻的振动数据映射为0~3级故障等级。

3.5 两类传感器阈值配置方式

在`sensor_service.py`中，软件为不同类型的传感器分别配置阈值：
1. 振动类监测点阈值：
   ```python
   cfg = SimpleThresholdConfig(level1=5.0, level2=10.0, level3=20.0)
   ```
   对应曲柄、轴承等振动监测点，含义为：
   - 振动速度 ≥ 5.0 mm/s 触发一级告警；
   - 振动速度 ≥ 10.0 mm/s 触发二级告警；
   - 振动速度 ≥ 20.0 mm/s 触发三级告警。

2. 光电类监测点阈值：
   ```python
   cfg_photo = SimpleThresholdConfig(level1=310.0, level2=320.0, level3=330.0)
   ```
   对应皮带/线型光电监测点，示例阈值为：
   - 采样值 ≥ 310 触发一级告警；
   - 采样值 ≥ 320 触发二级告警；
   - 采样值 ≥ 330 触发三级告警。

通过这样的设计，软件可以为不同监测对象使用各自合适的阈值区间，同时复用同一套阈值判定逻辑。

3.6 故障状态文件与跨进程共享

当`sensor_service`计算出各监测点的故障等级后，会将最新的状态写入一个JSON文件（默认路径`/tmp/sensor_fault_state.json`），内容包括：
- 每个监测点的当前数值和对应故障等级；
- 电气状态（三相是否正常）；
- 时间戳等。

此状态文件是系统内部的“数据总线”，其它进程（如`alarm_service`或调试UI）通过读取该文件即可获得全局传感器故障概览，而无需重复采集现场数据。这样实现了采集与报警模块的解耦，也便于后期拓展更多上层应用。

（下篇将在文件“2”中继续说明：包括报警引擎、RTU寄存器写入逻辑、101/3501/43501寄存器交互关系、系统日志与部署方式等。）

